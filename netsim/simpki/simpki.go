// SPDX-License-Identifier: GPL-3.0-or-later

// Package simpki allows to simulate a PKI for testing purposes.
//
// It allows to generate self-signed certificates and to cache them in
// a directory to avoid regenerating them at every run.
//
// Because this package is only meant to run as part of integration
// tests, all the functions panic on failure.
package simpki

import (
	"crypto/tls"
	"crypto/x509"
	"encoding/base64"
	"os"
	"path/filepath"

	"github.com/rbmk-project/common/runtimex"
	"github.com/rbmk-project/common/selfsignedcert"
	"github.com/rogpeppe/go-internal/lockedfile"
)

// PKI models the public key infrastructure.
//
// Construct using [NewPKI].
type PKI struct {
	cacheDir string
	pool     *x509.CertPool
}

// MustNew constructs a new [*PKI] instance using
// the given filesystem directory to store the
// certificates, to avoid regenerating them every
// time we run integration tests.
//
// This function panics on failure.
func MustNew(cacheDir string) *PKI {
	return &PKI{
		cacheDir: cacheDir,
		pool:     x509.NewCertPool(),
	}
}

// Config is an alias for [selfsignedcert.Config].
type Config = selfsignedcert.Config

// MustNewCert creates the certificate using the given
// [*Config] and using the cache directory
// to avoid regenerating the certificate every time.
//
// It returns the [tls.Certificate] to use in server code.
//
// As a side effect, this method also updates the
// certificate pool you can get with [*PKI.CertPool].
//
// This function panics on failure.
func (pki *PKI) MustNewCert(config *Config) tls.Certificate {
	// ensure there are no race conditions with concurrent invocations
	baseDir := filepath.Join(pki.cacheDir, "pkistore")
	runtimex.Try0(os.MkdirAll(baseDir, 0700))
	mu := lockedfile.MutexAt(filepath.Join(baseDir, ".lock"))
	unlock := runtimex.Try1(mu.Lock())
	defer unlock()

	// possibly create the base directory for the certificate
	dirname64 := base64.URLEncoding.EncodeToString([]byte(config.CommonName))
	dirpath := filepath.Join(baseDir, dirname64)
	runtimex.Try0(os.MkdirAll(dirpath, 0700))

	// check whether cert.pem already exists
	certPEM := filepath.Join(dirpath, "cert.pem")
	hasCertPEM := false
	if sbuf, err := os.Stat(certPEM); err == nil && sbuf.Mode().IsRegular() {
		hasCertPEM = true
	}

	// check whether key.pem already exists
	keyPEM := filepath.Join(dirpath, "key.pem")
	hasKeyPEM := false
	if sbuf, err := os.Stat(keyPEM); err == nil && sbuf.Mode().IsRegular() {
		hasKeyPEM = true
	}

	// regenerate the certificate if we miss either cert.pem or key.pem
	if !hasCertPEM || !hasKeyPEM {
		selfsignedcert.New(config).WriteFiles(dirpath)
	}

	// load the certificate and ensure we update the cert pool
	certPEMData := runtimex.Try1(os.ReadFile(certPEM))
	keyPEMData := runtimex.Try1(os.ReadFile(keyPEM))
	runtimex.Assert(pki.pool.AppendCertsFromPEM(certPEMData), "could not append certificate to pool")
	return runtimex.Try1(tls.X509KeyPair(certPEMData, keyPEMData))
}

// CertPool returns the certificate pool that contains
// all the certificates generated by this PKI.
func (pki *PKI) CertPool() *x509.CertPool {
	return pki.pool
}
